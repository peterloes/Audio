/***************************************************************************//**
 * @file
 * @brief	AUDIO
 * @author	Peter Loes
 * @version	2019-11-12
 *
 * This module provides the functionality to communicate with the AUDIO module.
 * It contains the following parts:
 * - Power management for FN-RM01 MP3 Audio Recorder and USART
 * - USART driver to transmit and receive data from the Audio module
 * - Handler for the transmit and received data
 *
 * @see LightBarriers.c
 *
 ****************************************************************************//*
 *
 * Parts are Copyright 2013 Energy Micro AS, http://www.energymicro.com
 *
 *******************************************************************************
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 * 4. The source and compiled code may only be used on Energy Micro "EFM32"
 *    microcontrollers and "EFR4" radios.
 *
 * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
 * obligation to support this Software. Energy Micro AS is providing the
 * Software "AS IS", with no express or implied warranties of any kind,
 * including, but not limited to, any implied warranties of merchantability
 * or fitness for any particular purpose or warranties against infringement
 * of any proprietary rights of a third party.
 *
 * Energy Micro AS will not be liable for any consequential, incidental, or
 * special damages, or any other relief, or for any claim by any third party,
 * arising from your use of this Software.
 *

 ****************************************************************************//*
Revision History:
2019-11-12,Loes	Initial version.
*/

/*=============================== Header Files ===============================*/

#include <stdio.h>
#include <string.h>
#include "em_device.h"
#include "em_assert.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_usart.h"
#include "AlarmClock.h"
#include "Audio.h"
#include "Logging.h"
#include "Control.h"

/*=============================== Definitions ================================*/

    // Module Debugging
#define MOD_DEBUG	0	// set 1 to enable debugging of this module



#if ! MOD_DEBUG
    #undef  DBG_PUTC
    #undef  DBG_PUTS
    #define DBG_PUTC(ch)	// define as empty
    #define DBG_PUTS(str)
#endif

    /*!@name Hardware Configuration: Power Enable for AUDIO module. */
//@{
#define AUDIO_POWER_PORT		gpioPortA	//!< Port for power control

#define AUDIO_POWER_PIN		3		//!< Power Pin: 0=OFF, 1=ON
    //! Set level of the power enable pin
#define SET_AUDIO_POWER_PIN(level) IO_Bit(GPIO->P[AUDIO_POWER_PORT].DOUT, \
                                          AUDIO_POWER_PIN) = (level)
//@}

    /*!@brief Time in [s] to wait for Audio being ready after power-up. */
#define POWER_UP_DELAY		5

    /*!@brief Maximum Communication Error Count before giving up. */
#define MAX_COM_ERROR_CNT	10


/*=========================== Typedefs and Structs ===========================*/

   /*!@name Hardware Configuration: Serial Communication via UART. */

/*!@brief Local structure to hold UART specific parameters */
typedef struct
{
    USART_TypeDef *	   const UART;		//!< UART device to use
    CMU_Clock_TypeDef	   const cmuClock_UART;	//!< CMU clock for the UART
    IRQn_Type		   const UART_Rx_IRQn;	//!< Rx interrupt number
    GPIO_Port_TypeDef	   const UART_Rx_Port;	//!< Port for RX pin
    uint32_t		   const UART_Rx_Pin;	//!< Rx pin on this port
    IRQn_Type		   const UART_Tx_IRQn;	//!< Tx interrupt number
    GPIO_Port_TypeDef	   const UART_Tx_Port;	//!< Port for TX pin
    uint32_t		   const UART_Tx_Pin;	//!< Tx pin on this port
    uint32_t		   const UART_Route;	//!< Route location
    uint32_t		   const Baudrate;	//!< Baudrate for the Audio
    USART_Databits_TypeDef const DataBits;	//!< Number of data bits
    USART_Parity_TypeDef   const Parity;	//!< Parity mode
    USART_Stopbits_TypeDef const StopBits;	//!< Number of stop bits
} USART_ParmsAudio;


 /*!@name Hardware Configuration: Serial Communication via UART. */
//@{
static const USART_ParmsAudio l_Audio_USART =
{
    USART0, cmuClock_USART0,		//!< select USART0
    USART0_RX_IRQn, gpioPortE, 11,	//!< Rx is PE11
    USART0_TX_IRQn, gpioPortE, 10,	//!< Tx is PE10
    USART_ROUTE_LOCATION_LOC0,		//!< routed thru location #0
    9600, usartDatabits8,		//!< Communication parameters for the
    usartNoParity, usartStopbits1	//!< FN-RM01 MP3 Audio 9600/8/N/1
};
//@}

/*========================= Global Data and Routines =========================*/

    /*!@brief Duration in [s] after which the AUDIO module is powered-off. */
int32_t  g_AUDIO_PwrOffTimeout = DFLT_AUDIO_POWER_OFF_TIMEOUT;

    /*!@brief Duration in [s] during the AUDIO mdoule tries to read an command. */
int32_t  g_AUDIO_DetectTimeout = DFLT_AUDIO_DETECT_TIMEOUT;

    /*!@brief Volume Control: Parameter [xx] total of 32 volume levels,
     * 31 by default. */
uint32_t  g_AudioCfg_VC;

    /*!@brief Storage Device: Parameter [xx] SD card by default. */
uint32_t  g_AudioCfg_ST;
  
   /*!@brief Choose audio-recording input mode: Parameter [xx] MIC by default. */
uint32_t  g_AudioCfg_IM;

   /*!@brief Set audio-recording quality(bit rate): Parameter [xx] 128kps
    * by default. */
uint32_t  g_AudioCfg_RQ;

/*================================ Local Data ================================*/  

    /*!@brief Retrieve information after AUDIO module has been initialized. */
static bool	 l_flgInit;

    /*!@brief Flag that determines if AUDIO module is in use. */
static bool	 l_flgAUDIO_Activate;

    /*! Timer handle for switching the AUDIO module off after a time. */
static volatile TIM_HDL	l_hdlAUDIO_Off = NONE;

    /*! Flag if AUDIO should be powered on. */
static volatile bool	l_flgAUDIO_On;

    /*! Flag if AUDIO module is currently powered on. */
static volatile bool	l_flgAUDIO_IsOn;

    /*! Current state of the Audio system. */
volatile AUDIO_STATE l_State;

    /*! Flag indicates if an object is present. */
static volatile bool	l_flgObjectPresent;

    /*! Flag if a new run has been started, i.e. the module is prepared to
     *  receive a command. */
static volatile bool	l_flgNewRun;

    /*! Timer handle for "Communication Watchdog". */
static volatile TIM_HDL	l_hdlWdog = NONE;


    /*! Variables for the communication with the AUDIO module. */
static char	l_TxBuffer[15];		//!< Transmit buffer
static volatile uint8_t	l_TxIdx;	//!< Index within the transmit buffer
static volatile bool	l_flgTxComplete;//!< true: Command has been sent
static volatile uint8_t	l_ComErrorCnt;	//!< Communication Error Count
static char	l_RxBuffer[150];	//!< Receive buffer
static volatile uint8_t	l_RxIdx;	//!< Index within the receive buffer

    /*! Flag if Work_Status replay received. */
static volatile bool	l_WorkStatus;

    /*! Flag if status 0xCA first time received. */
static volatile bool	l_CAStatus_1;

    /*! Flag if status 0xCA XX first time received. */
static volatile bool	l_CAStatus_2;

    /*! Flag if AUDIOData 0x00 received. */
static volatile int l_CheckAUDIOData;

     /* converter hex into int */
static volatile int a, b, c, d;




/*=========================== Forward Declarations ===========================*/


       /*! Switch AUDIO module off */
static void SwitchAUDIO_Off(TIM_HDL hdl);

       /*! AUDIO Communication Timeout */
static void AUDIO_ComTimeout(TIM_HDL hdl);

      /* Power On AUDIO */
static void AUDIO_PowerOn (void);

    /*! Check AUDIO data */
static void CheckAUDIOData ();

    /*! AUDIO USART Setup Routine */
static void AUDIO_UartSetup(void);


/***************************************************************************//**
 *
 * @brief	Initialize AUDIO Module
 *
 * This routine initializes the GPIO pins which are connected to the external
 * AUDIO module. The GPIO ports and pins have been defined in the header file.
 *
 ******************************************************************************/
void	AUDIO_Init (void)
{
     /* Check if AUDIO module is already in use */
    if (l_flgAUDIO_Activate)
	AUDIO_PowerOff();	// power-off and reset audio module and UART
    
        /* Now the AUDIO module isn't active any more */
    l_flgAUDIO_Activate = false;
    
        /* AUDIO module should be activated and initialized */
    l_flgAUDIO_Activate = true;
    l_flgInit = true;
    
#ifdef LOGGING   
    Log ("Audio Volume control value VC is %ld", g_AudioCfg_VC);
#endif
    if (g_AudioCfg_VC > 32)
	LogError("Audio: VC value must be between 1 and 31");
    
#ifdef LOGGING   
    Log ("Audio Choose a storage device ST is %ld",
	 g_AudioCfg_ST);
#endif
    if (g_AudioCfg_ST > 1)
	LogError("Audio: ST value must be between 0 and 1");

#ifdef LOGGING   
    Log ("Audio Choose audio-recording input mode IM is %ld", g_AudioCfg_IM);
#endif
    if (g_AudioCfg_IM > 2)
	LogError("Audio: Input Mode must be between 0 and 2");
    
#ifdef LOGGING   
    Log ("Audio recording quality (bit rate) mode RQ is %ld", g_AudioCfg_RQ);
#endif
    if (g_AudioCfg_RQ > 3)
	LogError("Audio: Recording Quality must be between 0 and 3");

    
    /* Get a timer handle to switch the AUDIO module off after a time */
    if (l_hdlAUDIO_Off == NONE)
	l_hdlAUDIO_Off = sTimerCreate (SwitchAUDIO_Off);
     
    /* Create another timer for a "Communication Watchdog" */
    if (l_hdlWdog == NONE)
	l_hdlWdog = sTimerCreate (AUDIO_ComTimeout);
    
    /*! Flag if Work_Status replay received. */
    l_WorkStatus = false;
    
  
}


/***************************************************************************//**
 *
 * @brief	Check if AUDIO module is active
 *
 * This routine lets you determine if the AUDIO module is in use, i.e. if it
 * has been configured.  It does <b>not</b> tell if the AUDIO module is enabled,
 * use IsAUDIO_Enabled() for this purpose.
 *
 * @see IsAUDIO_Enabled()
 *
 ******************************************************************************/
bool	IsAUDIO_Active (void)
{
    return l_flgAUDIO_Activate;
}


/***************************************************************************//**
 *
 * @brief	Enable AUDIO module
 *
 * This routine enables the AUDIO module, i.e. it notifies the AUDIO module 
 * software to power up and initialize the module and the related hardware.
 * It is usually called by PowerControl().
 *
 * @see AUDIO_Disable(), AUDIO_TimedDisable(), AUDIO_Check()
 *
 ******************************************************************************/
void AUDIO_Enable(void)
{
    /* set flag to notify there is an object present */
    l_flgObjectPresent = true;
   
    /* initiate power-on of the AUDIO hardware */
    l_flgAUDIO_On = true;
    
    if (l_hdlAUDIO_Off != NONE)
	sTimerCancel (l_hdlAUDIO_Off);	// inhibit power-off of AUDIO module
    
    /* re-trigger "new run" flag */
    l_flgNewRun = true;
    DBG_PUTS(" DBG AUDIO_Enable: setting l_flgNewRun=1\n");
    
     /* (re-)start timer for AUDIO timeout detection */
    DBG_PUTS("DBG AUDIO_Enable: starting Detect Timeout\n");
        if (l_hdlWdog != NONE)
	sTimerStart (l_hdlWdog, g_AUDIO_DetectTimeout);
    
}


/***************************************************************************//**
 *
 * @brief	Disable AUDIO module
 *
 * This routine immediately disables the AUDIO module.
 *
 * @see AUDIO_Enable(), AUDIO_TimedDisable(), AUDIO_Check()
 *
 ******************************************************************************/
void AUDIO_Disable (void)
{
   /* no object present, clear flag */
    l_flgObjectPresent = false;
   
    /* be sure to cancel timeout timer */
    if (l_hdlWdog != NONE)
	sTimerCancel (l_hdlWdog);
    
    if (l_flgAUDIO_On)
    {
	l_flgAUDIO_On = false;           // mark AUDIO module to be powered off
        
	if (l_hdlAUDIO_Off != NONE)
	    sTimerCancel (l_hdlAUDIO_Off);	// cancel timer
        
	/* AUDIO module should be powered OFF */
	if (l_flgAUDIO_IsOn)
	{
	    AUDIO_PowerOff();
	    l_flgAUDIO_IsOn = false;
	}
    }
}


/***************************************************************************//**
 *
 * @brief	Check if AUDIO module is enabled
 *
 * This routine returns the current power state of the AUDIO module.
 *
 * @see AUDIO_Enable(), AUDIO_Disable(), AUDIO_TimedDisable(), AUDIO_Check()
 *
 ******************************************************************************/
bool	IsAUDIO_Enabled (void)
{
    return l_flgAUDIO_On;
}


/***************************************************************************//**
 *
 * @brief	Disable AUDIO module after a while
 *
 * This routine disables the AUDIO module, i.e. it notifies the AUDIO software
 * module to power down the audio module after a delay of
 * @ref g_AUDIO_PwrOffTimeout seconds.
 *
 * @see AUDIO_Enable(), AUDIO_Disable(), AUDIO_Check()
 *
 ******************************************************************************/
void AUDIO_TimedDisable (void)
{
    /* no object present, clear flag */
    l_flgObjectPresent = false;
    
    /* be sure to cancel timeout timer */
    if (l_hdlWdog != NONE)
	sTimerCancel (l_hdlWdog);

  /* (re-)start timer to switch the AUDIO module OFF after time */
    if (l_hdlAUDIO_Off != NONE)
	sTimerStart (l_hdlAUDIO_Off, g_AUDIO_PwrOffTimeout);
}


/***************************************************************************//**
 *
 * @brief	Power AUDIO module On
 *
 * This routine powers the AUDIO module on and initializes the related hardware.
 *
 ******************************************************************************/
static void AUDIO_PowerOn (void)
{
    if (l_flgAUDIO_Activate)
    {      
#ifdef LOGGING
	/* Generate Log Message */
	Log ("AUDIO Module is powered ON");
#endif
      
    /* (Re-)initialize variables */
    l_flgTxComplete = false;
   
    /* Module Audio requires EM1, set bit in bit mask */
    Bit(g_EM1_ModuleMask, EM1_MOD_AUDIO) = 1;
    
    /* Prepare UART to communicate with AUDIO module */
    AUDIO_UartSetup();
   
    /* Configure Power Enable Pin for AUDIO Module, switch it ON */
    GPIO_PinModeSet (AUDIO_POWER_PORT, AUDIO_POWER_PIN, gpioModePushPull, 1);
     
    /* Skip command after power on RX IRQ Handler 0xCA */
    l_CAStatus_1 = false;
    
        /* Skip command after power on RX IRQ Handler 0xCAXX */
    l_CAStatus_2 = false;
    
    /* Wait some time until Audio is up and running */
    l_State = AUDIO_STATE_POWER_ON;
    if (l_hdlWdog != NONE)
	    sTimerStart (l_hdlWdog, POWER_UP_DELAY);

#ifdef LOGGING
	/* Generate Log Message */
	Log ("Waiting %ds for AUDIO being ready to accept commands...",
	     POWER_UP_DELAY);
#endif
        
    }
}


/***************************************************************************//**
 *
 * @brief	Power AUDIO module Off
 *
 * This routine powers the AUDIO module immediately off.
 *
 ******************************************************************************/
void AUDIO_PowerOff (void)
{
     /* Set Power Enable Pin for the AUDIO receiver to OFF */
    SET_AUDIO_POWER_PIN(0);  
       
    /* Set Power Enable Pin for the Audio to OFF */
    l_State = AUDIO_STATE_OFF;
      
    /* Clear Audio-related error conditions */
    ClearError(ERR_SRC_AUDIO);
  
    /* Disable clock for USART module */
    CMU_ClockEnable(l_Audio_USART.cmuClock_UART, false);

    /* Disable Rx and Tx pins */
    GPIO_PinModeSet(l_Audio_USART.UART_Rx_Port,
		    l_Audio_USART.UART_Rx_Pin, gpioModeDisabled, 0);
    GPIO_PinModeSet(l_Audio_USART.UART_Tx_Port,
		    l_Audio_USART.UART_Tx_Pin, gpioModeDisabled, 0);
    
    /* Module AUDIO is no longer active, clear bit in bit mask */
    Bit(g_EM1_ModuleMask, EM1_MOD_AUDIO) = 0;
    
    /* Reset index */
    l_State = 0;
    
#ifdef LOGGING
    /* Generate Log Message */
    Log ("AUDIO Module is powered off");
#endif
  
}


/***************************************************************************//**
 *
 * @brief	AUDIO Check
 *
 * This function checks if the AUDIO module needs to be powered on or off.
 *
 * @note
 * 	This function may only be called from standard program, usually the loop
 * 	in file main.c - it must not be called from interrupt routines!
 *
 ******************************************************************************/
void	AUDIO_Check (void)
{
    if (l_flgAUDIO_On)
    {
	/* AUDIO module should be powered ON */
	if (! l_flgAUDIO_IsOn)
	{
	    AUDIO_PowerOn();
	    l_flgAUDIO_IsOn = true;
	}
    }
    else
    {
	/* AUDIO module should be powered OFF */
	if (l_flgAUDIO_IsOn)
	{
		AUDIO_PowerOff();
		l_flgAUDIO_IsOn = false;
	}
    }
}
  

/***************************************************************************//**
 *
 * @brief	AUDIO Power Fail Handler
 *
 * This function will be called in case of power-fail to bring the AUDIO
 * hardware into a quiescent, power-saving state.
 *
 ******************************************************************************/
void	AUDIO_PowerFailHandler (void)
{
 
      /* Cancel timers */
    if (l_hdlAUDIO_Off != NONE)
    	sTimerCancel (l_hdlAUDIO_Off);
    
    if (l_hdlWdog != NONE)
       sTimerCancel (l_hdlWdog);
    
 
    /* Switch AUDIO module off */
    l_flgAUDIO_On = false;

    if (l_flgAUDIO_IsOn)
    {
	AUDIO_PowerOff();
	l_flgAUDIO_IsOn = false;
    }
}


/***************************************************************************//**
 *
 * @brief	Switch AUDIO module Off
 *
 * This routine is called from the RTC interrupt handler, after the specified
 * amount of time has elapsed, to trigger the power-off of the AUDIO module.
 *
 ******************************************************************************/
static void SwitchAUDIO_Off(TIM_HDL hdl)
{
    (void) hdl;		// suppress compiler warning "unused parameter"

    l_flgAUDIO_On = false;

    g_flgIRQ = true;	// keep on running
}


/***************************************************************************//**
 *
 * @brief	AUDIO Communication Timeout
 *
 * This routine is called from the RTC interrupt handler, after the specified
 * amount of time has elapsed to notify a "Communication Timeout" with the
 * AUDIO module.  This means the firmware did not respond within time.
 * The error is logged, then the recovery of the audio module is initiated.
 *
 ******************************************************************************/
static void AUDIO_ComTimeout(TIM_HDL hdl)
{
AUDIO_STATE	startState;

    (void) hdl;		// suppress compiler warning "unused parameter"

    /* Check error count */
    if (l_ComErrorCnt > MAX_COM_ERROR_CNT)
    {
	l_State = AUDIO_STATE_OFF;
	AUDIO_Disable();
	return;
    }

    if (l_State == AUDIO_STATE_RECOVER)
    {
	l_State = AUDIO_STATE_POWER_ON;
	AUDIO_Enable();
	return;
    }

    /* Check for power-up problems */
    if (l_ComErrorCnt == 0  &&  l_State == AUDIO_GET_WORK_STATUS)
    {
#ifdef LOGGING
	LogError ("AUDIO: Timeout during initialization"
		  " - AUDIO not connected?");
#endif
      
      l_State = AUDIO_STATE_OFF;
	AUDIO_Disable();
	return;
    }

       /* See if power-up time of audio module is over */
    if (l_State == AUDIO_STATE_POWER_ON)
    {
	if (l_flgInit)
	{
	    l_flgInit = false;		// do this only once
#ifdef LOGGING
	    Log ("AUDIO should be ready, retrieving hard- and software"
		 " information");
#endif
	     
            startState = AUDIO_GET_WORK_STATUS;
                                  
	}
	else
	{
    
#ifdef LOGGING
	    Log ("AUDIO should be ready, sending configuration values");
#endif
	    startState = AUDIO_STATE_SEND_VC;

	}
	l_flgTxComplete = true;
	AUDIO_SendCmdSeq(startState);

	return;
    }
    
    /* Otherwise it is a real timeout, i.e. error */
    l_ComErrorCnt++;	// increase error count

#ifdef LOGGING
    LogError ("AUDIO: %d. Communication Timeout in state %d",
	      l_ComErrorCnt, l_State);
#endif

    /* Otherwise initiate recovery of the scales system */
    if (l_ComErrorCnt < MAX_COM_ERROR_CNT)
    {
	/* Immediately disable and power off the audio system */
	AUDIO_Disable();	// calls AUDIO_PowerOff(), sets AUDIO_STATE_OFF

	/* Try to recover in 3 seconds */
	l_State = AUDIO_STATE_RECOVER;
#ifdef LOGGING
    Log ("Try to recover Audio");
#endif
    	if (l_hdlWdog != NONE)
	    sTimerStart (l_hdlWdog, 60);
    }
    else
    {
#ifdef LOGGING
	LogError ("AUDIO: MAX_COM_ERROR_CNT (%d) exceeded", MAX_COM_ERROR_CNT);
#endif
    }
}


/***************************************************************************//**
 *
 * @brief	Start sending a Command Sequence to AUDIO
 *
 * This routine starts to send the specified command of a complete sequence.
 * The next command is usually selected by CheckAUDIOData().
 *
 * @param[in] state
 *	Must be of type @ref AUDIO_STATE.  Specifies the command to send.
 *
 ******************************************************************************/
void AUDIO_SendCmdSeq(AUDIO_STATE state)
{

int  checksum_int;

char  buffer[40];
const char *cmd;

    cmd = buffer;
    switch (state)
    {
	case AUDIO_GET_WORK_STATUS:  // 4.4.2 Current work status
           sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xC2, 0xC5, 0x7E);
           break;
 
       case AUDIO_GET_CONNECTION_STATUS: // 4.4.6 Current status SD or USB flash
          /* RX IRQ Handler allowed 0xCA */ 
          l_CAStatus_1 = true; 
	  sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xCA, 0xCD, 0x7E);
          break;
 
       case AUDIO_GET_FILE_NUMBERS:  // 4.4.3 Total file numbers on SD card or USB flash
	  sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xC5, 0xC8, 0x7E);
          break;

       case AUDIO_GET_SPACE_LEFT:  // 4.4.9 Space left in the storage device
	  sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xCE, 0xD1, 0x7E);
          break;
             
       case AUDIO_STATE_SEND_VC:    // Send 4.3.9. Volume control
          /* checksum integer calculation [0x04, 0xAE, 0x1F]*/
          checksum_int = 4 + 174 + g_AudioCfg_VC; // + 29 = 207
          sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xAE, g_AudioCfg_VC, checksum_int, 0x7E);
          break;
          
       case AUDIO_STATE_SEND_ST:    // Send 4.3.13. Storage device
           if (g_AudioCfg_ST != 0)  // 00: Do not send default SD Card 
           {
               /* 01: shift to USB flash drive */
               sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD2, 0x01, 0xD7, 0x7E);
              // checksum decimal: 4+210+1 = 215 dec. / 0xD7
           }
           else
           {
              /* 00: shift to SD Card (by default) */
              sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD2, 0x00, 0xD6, 0x7E);
             // checksum decimal: 4+210+0 = 214 dec. / 0xD6
           }             
           break;

       case AUDIO_STATE_SEND_IM:   // Send 4.3.14. Input Mode
           if (g_AudioCfg_IM != 0)  // 00: Do not send default (MIC) 
           {
              if(g_AudioCfg_IM == 1)
              {
                 /* 01: connect with LINE-IN */
                sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD3, 0x01, 0xD8, 0x7E);
              }
              else
              {
                 /* 02: connect with 2-channel Aux-In signal */
                sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD3, 0x02, 0xD9, 0x7E);
              }
           }
           else
           {
                /* 00: connect with MIC (signal P03) default */
                sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD3, 0x00, 0xD7, 0x7E);
           }
           break;

       case AUDIO_STATE_SEND_RQ:   // Send 4.3.15. recording quality
          if (g_AudioCfg_RQ != 0)  // 00: Do not send default (128kbps)  
          {
              if(g_AudioCfg_RQ == 1)
              {
                 /* 01: 96kbps */
                 sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD4, 0x01, 0xD9, 0x7E);
              }
              else
              {
                 if(g_AudioCfg_RQ == 2)
                 {
                    /* 02: 64kbps */
                    sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD4, 0x02, 0xDA, 0x7E);
                 }
                 else
                 {  /* 03: 32kps */
                    sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD4, 0x03, 0xDB, 0x7E);
                 }
              }
           }
           else
           {
               /* 00: 128kbps */
                 sprintf(buffer, "%c%c%c%c%c%c", 0x7E, 0x04, 0xD4, 0x01, 0xD8, 0x7E);
           }
           break;
          
       case AUDIO_SEND_PLAYBACK:     // 4.3.2 Specify playback of a file by name [P001.wav]
	     sprintf(buffer, "%c%c%c%c%c%c%c%c%c", 0x7E, 0x07, 0xA3, 0x50, 0x30, 0x30, 0x31, 0x8B, 0x7E);
             // checksum decimal: 7+163+80+48+48+49 = 395 dec. / 0x18B
             //cmd = "7E07A3503030318F7E";
	     break;
            
	case AUDIO_SEND_RECORD:	   // 4.3.17 Specify recording of a file by name [R001.wav]
	     sprintf(buffer, "%c%c%c%c%c%c%c%c%c", 0x7E, 0x07, 0xD6, 0x52, 0x30, 0x30, 0x31, 0xC0, 0x7E);
             // checksum decimal: 7+214+82+48+48+49 = 448 dec. / 0x1C0
             //cmd = "7E07D6523030314A7E";// [R001]    
             break;
       
       case AUDIO_SEND_PLAYBACK_STOP:    // 4.3.6 Stop playback
	     sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xAB, 0xAE, 0x7E);
             //cmd = "7E03ABAE7E";
	     break;
 
        case AUDIO_SEND_RECORD_STOP:	  // 4.3.20 Stop recording 
             sprintf(buffer, "%c%c%c%c%c", 0x7E, 0x03, 0xD9, 0xDC, 0x7E);
             //cmd = "7E03D9DC7E";
             break;

     default:
#ifdef LOGGING
	    LogError("AUDIO AUDIO_SendCmdSeq(): INVALID STATE %d", state);
#endif       
	    cmd =  NULL;
	    state = AUDIO_STATE_OFF;
    }

    l_State = state;		// save current state into local variable

    if (cmd != NULL)
	SendCmd(cmd);
}


/***************************************************************************//**
 *
 * @brief	Send Command
 *
 * Send a command to the AUDIO module.
 *
 * @param[in] pCmdStr
 *	Address pointer of the string to be written into the transmit buffer.
 *
 ******************************************************************************/
void SendCmd(const char *pCmdStr)
{
  
   /* Check if previous command has been written already */
    if (! l_flgTxComplete)
    {
#ifdef LOGGING
	LogError("AUDIO SendCmd(%s): Previous command still pending", pCmdStr);
#endif
    }  

   /* Check length */
    unsigned int len = strlen(pCmdStr);
    if (len > sizeof(l_TxBuffer) - 2)
    {
#ifdef LOGGING
	LogError("AUDIO SendCmd(%s): Command too long (%d bytes)", pCmdStr, len);
#endif
	return;		// ignore this command
    }

    /* Copy command string into transmit buffer */
    strcpy(l_TxBuffer, pCmdStr);

    /* Clear flag, reset index */
    l_flgTxComplete = false;
    l_TxIdx = 0;

    /* Enable Tx interrupt to start sending */
    USART_IntSet(l_Audio_USART.UART, USART_IF_TXBL);
    USART_IntEnable(l_Audio_USART.UART, USART_IEN_TXBL);

    /* Start watchdog */
    if (l_hdlWdog != NONE)
	sTimerStart (l_hdlWdog, 60);
}


/***************************************************************************//**
 *
 * @brief	Check AUDIO Data
 *
 * This routine is called from AUDIO RX Handler to check the Work Status 
 * and other information from the audio module.
 *
 ******************************************************************************/
static void CheckAUDIOData (void)
{
    /* Cancel watchdog timer */
    if (l_hdlWdog != NONE)
	sTimerCancel(l_hdlWdog);

#if MOD_DEBUG	// for debugging only
    Log("AUDIO Data: '%s' state=%d", l_RxBuffer, l_State);
#endif
     
    /* Consider state */
    switch (l_State)
    {
        case AUDIO_GET_WORK_STATUS:	 // 4.4.2 Current work status 
           if (l_RxBuffer[0] == 0xC2)  
	   {
                /* Connection Status operation code 0xCA is received */
               if (l_CheckAUDIOData >= 1)
               {     
                  /* Work Status operation code 0xC2 is received */
                  if (l_RxBuffer[1] == 0x01) // 0x01: Playing
                  {
                      l_CheckAUDIOData = 0;
                      Log ("AUDIO: Playing  0x%02X%02X", l_RxBuffer[0],l_RxBuffer[1]);
                      AUDIO_SendCmdSeq(l_State+1);
                  }
                  if (l_RxBuffer[1] == 0x02) // 0x02: Stopped
                  {
                      l_CheckAUDIOData = 0;
                      Log ("AUDIO: Stopped  0x%02X%02X", l_RxBuffer[0],l_RxBuffer[1]);
                      AUDIO_SendCmdSeq(l_State+1);
                   }
                   if (l_RxBuffer[1] == 0x03) // 0x03: Paused
                   {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: Paused  0x%02X%02X", l_RxBuffer[0],l_RxBuffer[1]);
                       AUDIO_SendCmdSeq(l_State+1);
                   }
                   if (l_RxBuffer[1] == 0x04) // 0x04: Recording
                   {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: Recording  0x%02X%02X", l_RxBuffer[0],l_RxBuffer[1]);
                       AUDIO_SendCmdSeq(l_State+1);
                   }
                   if (l_RxBuffer[1] == 0x05) // 0x05: Fast forward/backward
                   {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: Fast forward/backward  0x%02X%02X", l_RxBuffer[0],l_RxBuffer[1]);
                       AUDIO_SendCmdSeq(l_State+1);
                    }
                }
                l_CheckAUDIOData++;
            }     
            else
	    {
                 /* Work Status replay C2xx is not received */
                 LogError("AUDIO: Work Status 0x%02X", l_RxBuffer[0]);
                 SetError(ERR_SRC_AUDIO);	// indicate error via LED
                 l_WorkStatus = true;
            }
            break;
               
        case AUDIO_GET_CONNECTION_STATUS: // 4.4.6 Current status SD or USB flash
            if (l_RxBuffer[2] == 0xCA) 
	    {
                /* Connection Status operation code 0xCA is received */
                if (l_CheckAUDIOData >= 2)
                {     
                    if (l_RxBuffer[3] == 0x00) // 0x00: SD card and USB flash connected
                    {
                        l_CheckAUDIOData = 0;
                        Log ("AUDIO: both SD card and USB flash drive inserted 0x%02X%02X", l_RxBuffer[2],l_RxBuffer[3]);
                        AUDIO_SendCmdSeq(l_State+1);
                    }
                    if (l_RxBuffer[3] == 0x01) // 0x01: SD card connected
                    {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: SD card inserted  0x%02X%02X", l_RxBuffer[2],l_RxBuffer[3]);
                       AUDIO_SendCmdSeq(l_State+1);
                    }
                    if (l_RxBuffer[3] == 0x02) // 0x02: USB flash connected
                    {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: USB flash inserted  0x%02X%02X", l_RxBuffer[2],l_RxBuffer[3]);
                       AUDIO_SendCmdSeq(l_State+1);
                    }
                    if (l_RxBuffer[3] == 0x03) // 0x03: neither SD card or USB flash connected
                    {
                       l_CheckAUDIOData = 0;
                       Log ("AUDIO: SD card or USB flash removed 0x%02X%02X", l_RxBuffer[2],l_RxBuffer[3]);
                       AUDIO_SendCmdSeq(l_State+1);
                    }
               }
               l_CheckAUDIOData++;
            }
            else
            {
               /* Connection status CAxx is not received */
               LogError("AUDIO: Connection SD or USB flash Status 0x%02X", l_RxBuffer[2]);
               SetError(ERR_SRC_AUDIO);	// indicate error via LED
               l_WorkStatus = true;
            }
            break;
           
        case AUDIO_GET_FILE_NUMBERS:  // 4.4.3 Total file numbers on SD card or USB flash
           if (l_RxBuffer[4] == 0xC5)
	   {   
              /* Connection Status operation code 0xCA is received */
              if (l_CheckAUDIOData >= 3)
              {     
                 if (l_RxBuffer[6] != 0x00) // file number low digits
                 {
                     l_CheckAUDIOData = 0;
                     // Umrechnung hex into dez
                      a = ((l_RxBuffer[5] >> 4) & 0x0F) * 4096;// 16x16x16
                      b =  (l_RxBuffer[5] & 0x0F) * 256;       // 16x16
                      c = ((l_RxBuffer[6] >> 4) & 0x0F) * 16;  // 16
                      d =  (l_RxBuffer[6] & 0x0F) * 1;         // 1
                    
                      Log ("AUDIO: Total file number %d", a+b+c+d);
                      Log ("AUDIO: Please wait up to 50 sec. for capacity left");
                      AUDIO_SendCmdSeq(l_State+1);
                 }
                 else
                 {
                     LogError("AUDIO: no file number  0x%02X", l_RxBuffer[4]);
                     SetError(ERR_SRC_AUDIO);	// indicate error via LED
                     l_WorkStatus = true;
                 }
              }
              l_CheckAUDIOData++;
           }
           break;
                  
        case AUDIO_GET_SPACE_LEFT:   // 4.4.9 Space left in the storage device
           if (l_RxBuffer[7] == 0xCE) //getestet für 113 files
           {
               /* Connection Status operation code 0xCA is received */
               if (l_CheckAUDIOData >= 3)
               { 
                  /* Operation code 0xCA is received */
                  if (l_RxBuffer[9] != 0x00) // no space left on SD Card or USB flash
                  {
                     l_CheckAUDIOData = 0;
                     
                     // Umrechnung hex into dez
                     a = ((l_RxBuffer[8] >> 4) & 0x0F) * 4096;// 16x16x16
                     b =  (l_RxBuffer[8] & 0x0F) * 256;       // 16x16
                     c = ((l_RxBuffer[9] >> 4) & 0x0F) * 16;  // 16
                     d =  (l_RxBuffer[9] & 0x0F) * 1;         // 1
                    
                     Log ("AUDIO: Capacity left (Mb) %d", a+b+c+d);
                     AUDIO_SendCmdSeq(l_State+1);
                 }
                 else
                 {
                     LogError("AUDIO: No Space left 0x%02X", l_RxBuffer[7]);
                     SetError(ERR_SRC_AUDIO);	// indicate error via LED
                     l_WorkStatus = true;
                 }
             }
             l_CheckAUDIOData++;
          }
          break; 
  
       case AUDIO_STATE_SEND_VC:    // Send 4.3.9. Volume control
          /* Register [10] is 0x00 */
          if (l_RxBuffer[10] == 0x00) 
          {
              /* Check Safe Command executed or failed 0x00 / 0x01 is received */
              if (l_CheckAUDIOData >= 1)
              {
                 if (l_RxBuffer[10] == 0x00)// Command is executed succesfully
                 {
                    Log ("AUDIO: Volume %i is executed successfully", g_AudioCfg_VC);
                    AUDIO_SendCmdSeq(l_State+1);
                    l_CheckAUDIOData = 0;
                 }
              }
              l_CheckAUDIOData++;
          } 
          else
          {
             if (l_RxBuffer[10] == 0x01)// Command executed failed 
             {
                 Log ("AUDIO: Volume execution failed");
                 AUDIO_SendCmdSeq(l_State+1);
                 l_CheckAUDIOData = 0;
             }
         }
         break;
   
       case AUDIO_STATE_SEND_ST:    // Send 4.3.13. Storage device
         /* Register [11] is 0x00 */
         if (l_RxBuffer[11] == 0x00) 
         {
             /* Check Safe Command executed or failed 0x00 / 0x01 is received */
             if (l_CheckAUDIOData >= 1)
             { 
                 if (l_RxBuffer[11] == 0x00)// Shift to SD Card
                 {
                     Log ("AUDIO: SD card is supported");
                     AUDIO_SendCmdSeq(l_State+1);
                     l_CheckAUDIOData = 0;
                 }
             }
             l_CheckAUDIOData++;
          }
          else
          {
              if (l_RxBuffer[11] == 0x01)// Shift to USB flash drive 
              {
                 Log ("AUDIO: USB flash drive is supported");
                 AUDIO_SendCmdSeq(l_State+1);
                 l_CheckAUDIOData = 0;
              }
           }
           break; 
                   
       case AUDIO_STATE_SEND_IM:    // Send 4.3.14. Input Mode
          /* Register [12] is 0x00 */
          if (l_RxBuffer[12] == 0x00) 
          {
              /* Check Safe Command executed or failed 0x00 / 0x01 is received */
              if (l_CheckAUDIOData >= 1)
              { 
                 if (l_RxBuffer[12] == 0x00)// Command is executed succesfully
                 {
                    Log ("AUDIO: Input Mode %i is executed successfully", g_AudioCfg_IM );
                    AUDIO_SendCmdSeq(l_State+1);
                    l_CheckAUDIOData = 0;
                 }
              }
              l_CheckAUDIOData++;
           }
           else
           {
              if (l_RxBuffer[12] == 0x01)// Command executed failed
              {
                 Log ("AUDIO: Input Mode execution failed");
                 AUDIO_SendCmdSeq(l_State+1);
                 l_CheckAUDIOData = 0;
              }
           }
          break; 
   
      case AUDIO_STATE_SEND_RQ:   // Send 4.3.15. recording quality
         /* Register [13] is 0x00 */
         if (l_RxBuffer[13] == 0x00) 
         {
            /* Check Safe Command executed or failed 0x00 / 0x01 is received */
            if (l_CheckAUDIOData >= 1)
            { 
               if (l_RxBuffer[13] == 0x00)// Command is executed succesfully
               {
                  Log ("AUDIO: Recording quality %i is executed successfully ", g_AudioCfg_RQ);
                  l_CheckAUDIOData = 0;
               }
             }
             l_CheckAUDIOData++;
          }
          else
          {
             if (l_RxBuffer[13] == 0x01)// Command executed failed 
             {
                Log ("AUDIO: Recording quality execution failed");
                l_CheckAUDIOData = 0;
             }
          }
          break; 
            
	case AUDIO_SEND_PLAYBACK:	// 4.3.2 Specify playback of a file by name [P001.wav]
           if (l_RxBuffer[3] == 0x01)
	    {
              	LogError("AUDIO: Playback ON [T001.mp3] 0x%02X", l_RxBuffer[3]);
		SetError(ERR_SRC_AUDIO);	// indicate error via LED
	    }
	    else
	    {
                Log("AUDIO: Playback ON [T001.mp3] 0x%02X", l_RxBuffer[3]);
                ClearError(ERR_SRC_AUDIO);	// command sequence completed
               	//AUDIO_SendCmdSeq(l_State);
	    }
	    break;
         
        case  AUDIO_SEND_RECORD:	// 4.3.17 Specify recording of a file by name [R001.wav]
            if (strcmp(l_RxBuffer, "1") == 0)
	       {
                  LogError("AUDIO: RECORD ON 0x%02X", l_RxBuffer[4]);
		  SetError(ERR_SRC_AUDIO);	// indicate error via LED
               }
	       else
	       {
	          /* 00: command is executed successfully*/ 
                  Log("AUDIO: Record ON    : 0x%02X", l_RxBuffer[4]);
                  ClearError(ERR_SRC_AUDIO);	// command sequence completed
               	  //AUDIO_SendCmdSeq(l_State);
	       }
               break;
            
            	case AUDIO_SEND_PLAYBACK_STOP:	  // 4.3.6 Stop playback
	    if (l_RxBuffer[2] == 0x01)
	    {
		LogError("AUDIO: Playback off 0x%02X", l_RxBuffer[2]);
		SetError(ERR_SRC_AUDIO);	// indicate error via LED  
            }    
            else
	    {
                 Log("AUDIO: Playback off    0x%02X", l_RxBuffer[2]);
		// AUDIO_SendCmdSeq(l_State+1); 
             }
	    break;
            
	case AUDIO_SEND_RECORD_STOP:	  // 4.3.20 Stop recording
          if (l_RxBuffer[2] == 0x01)
	     {
                LogError("AUDIO: Record off 0x%02X", l_RxBuffer[2]);
		SetError(ERR_SRC_AUDIO);	// indicate error via LED
            }
	    else
	    {
               Log("AUDIO: Record off    0x%02X", l_RxBuffer[2]);
               //Log("AUDIO Module is operational now");
               ClearError(ERR_SRC_AUDIO);	// command sequence completed
               //AUDIO_SendCmdSeq(l_State+1);
            }
	    break;
   
	default:			// unknown state
            LogError("AUDIO: Received \"%s\" for unhandled state %d",
		     l_RxBuffer, l_State);
	    SetError(ERR_SRC_AUDIO);		// indicate error via LED
    }
}



/*============================================================================*/
/*=============================== UART Routines ==============================*/
/*============================================================================*/

/* Setup UART in async mode for RS232 */
static USART_InitAsync_TypeDef uartInit = USART_INITASYNC_DEFAULT;


/**************************************************************************//**
 * @brief AUDIO UART Setup Routine
 *****************************************************************************/
static void AUDIO_UartSetup(void)
{
    /* Enable clock for USART module */
    CMU_ClockEnable(l_Audio_USART.cmuClock_UART, true);

    /* Configure GPIO Rx and Tx pins - enable pull-up for Rx */
    GPIO_PinModeSet(l_Audio_USART.UART_Rx_Port,
		    l_Audio_USART.UART_Rx_Pin, gpioModeInputPull, 1);
    GPIO_PinModeSet(l_Audio_USART.UART_Tx_Port,
		    l_Audio_USART.UART_Tx_Pin, gpioModePushPull, 1);

    /* Prepare structure for initializing UART in asynchronous mode */
    uartInit.enable       = usartDisable;   // Don't enable UART upon initialization
    uartInit.refFreq      = 0;              // Set to 0 to use reference frequency
    uartInit.baudrate     = l_Audio_USART.Baudrate;
    uartInit.oversampling = usartOVS16;     // Oversampling. Range is 4x, 6x, 8x or 16x
    uartInit.databits     = l_Audio_USART.DataBits;
    uartInit.parity       = l_Audio_USART.Parity;
    uartInit.stopbits     = l_Audio_USART.StopBits;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
    uartInit.mvdis        = false;          // Disable majority voting
    uartInit.prsRxEnable  = false;          // Enable USART Rx via Peripheral Reflex System
    uartInit.prsRxCh      = usartPrsRxCh0;  // Select PRS channel if enabled
#endif

    /* Initialize USART with uartInit structure */
    USART_InitAsync(l_Audio_USART.UART, &uartInit);

    /* Prepare UART Rx and Tx interrupts */
    USART_IntClear(l_Audio_USART.UART, _USART_IFC_MASK);
    USART_IntEnable(l_Audio_USART.UART, USART_IEN_RXDATAV);
    NVIC_SetPriority(l_Audio_USART.UART_Rx_IRQn, INT_PRIO_UART);
    NVIC_SetPriority(l_Audio_USART.UART_Tx_IRQn, INT_PRIO_UART);
    NVIC_ClearPendingIRQ(l_Audio_USART.UART_Rx_IRQn);
    NVIC_ClearPendingIRQ(l_Audio_USART.UART_Tx_IRQn);
    NVIC_EnableIRQ(l_Audio_USART.UART_Rx_IRQn);
    NVIC_EnableIRQ(l_Audio_USART.UART_Tx_IRQn);

    /* Enable I/O pins at UART location #2 */
    l_Audio_USART.UART->ROUTE  = USART_ROUTE_RXPEN
				| USART_ROUTE_TXPEN
				| l_Audio_USART.UART_Route;

    /* Enable UART receiver only */
    USART_Enable(l_Audio_USART.UART, usartEnable);
}


/**************************************************************************//**
 * @brief USART0 RX IRQ Handler
 *****************************************************************************/
void USART0_RX_IRQHandler(void)
{
uint8_t rxData;

    /* Check for RX data valid interrupt */
    if (l_Audio_USART.UART->IF & USART_IF_RXDATAV)
    {
	/* Get byte from RX data register */
	rxData = l_Audio_USART.UART->RXDATA;
        
#if MOD_DEBUG	// for debugging only
	Log("DBG: 0x%02X ('%c')", rxData,rxData < ' '? '.':rxData);
#endif
	switch (rxData)
	{
	    case 0xCA:  // 4.4.6 Current status SD or USB flash sent after power-up
               if (l_CAStatus_1) //Skip command after power on 0xCA  
               {
               }
               else
               {
                  l_CAStatus_2 = true; // Skip command after power on 0xCAXX
                  break;
               }
               
            case 0x00:  // 4.4.6 Current status SD or USB flash sent after power-up
               if (l_CAStatus_2) //Skip command after power on 0xCAXX  
               {
                   l_CAStatus_2 = false; // Skip command after power on 0xCAXX
               }
               else
               {
                   l_RxBuffer[l_RxIdx++] = rxData;
                   CheckAUDIOData();
               }
               break;
               
         case 0x01: // 4.4.6 Current status SD Card inserted
               if (l_CAStatus_2) //Skip command after power on 0xCAXX  
               {
                   l_CAStatus_2 = false; // Skip command after power on 0xCAXX
               }
               else
               {
                   l_RxBuffer[l_RxIdx++] = rxData;
                   CheckAUDIOData();
               }
               break;
               
           case 0x02: // 4.4.6 Current status SD or USB flash sent after power-up
               if (l_CAStatus_2) //Skip command after power on 0xCAXX  
               {
                   l_CAStatus_2 = false; // Skip command after power on 0xCAXX
               }
               else
               {
                   l_RxBuffer[l_RxIdx++] = rxData;
                   CheckAUDIOData();
               }
               break;
               
            case 0x03: // 4.4.6 Current status SD Card removed
                if (l_CAStatus_2) //Skip command after power on 0xCAXX  
                {
                    l_CAStatus_2 = false; // Skip command after power on 0xCAXX
                }
                else
                {
                    l_RxBuffer[l_RxIdx++] = rxData;
                    CheckAUDIOData();
                }
                break;
                
            case 0x04: // 4.2 Current work status 
              
                l_RxBuffer[l_RxIdx++] = rxData;
                CheckAUDIOData();
                break;
          
            case 0x05: // 4.2 Current work status 
              
                l_RxBuffer[l_RxIdx++] = rxData;
                CheckAUDIOData();
                break;
                                          
            case 0xFF: // may be sent after power-up - just ignore
                   break;
                
            default:	// any other character
		   if (l_RxIdx < sizeof(l_RxBuffer) - 2)
		   {
		       l_RxBuffer[l_RxIdx++] = rxData;
                       CheckAUDIOData();
                   }
		   else if (l_RxIdx < sizeof(l_RxBuffer) - 1)
		   {
		       l_RxBuffer[l_RxIdx++] = EOS;
		       LogError("Audio: l_RxBuffer full - Data=\"%s\"",
			     l_RxBuffer);
		   }
                   break;                   
              
	} // switch (rxData)
    }
}


/**************************************************************************//**
 * @brief USART0 TX IRQ Handler
 *****************************************************************************/
void USART0_TX_IRQHandler(void)
{
uint8_t  txData;

    /* Check TX buffer level status */
    if (l_Audio_USART.UART->IF & USART_IF_TXBL)
    {
	/* Get the next character from the transmit buffer */
	txData = l_TxBuffer[l_TxIdx];

	if (txData != 0)
	{
	    /* Transmit next character */
	    l_Audio_USART.UART->TXDATA = (uint32_t)txData;
	    l_TxIdx++;
	}
	else
	{
	    /* Disable Tx interrupt if no more bytes in buffer */
	    USART_IntDisable(l_Audio_USART.UART, USART_IEN_TXBL);

	    /* Set flag to indicate data has been transmitted completely */
	    l_flgTxComplete = true;
	}
    }
}
